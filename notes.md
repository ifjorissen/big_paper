# Notes For the Big Paper
@ifjorissen

#### Fall break 2015
  * Installed Voro++, Triangle, QHull
  * Learn / Refresh C: [http://c.learncodethehardway.org/book/]
  * Cloned (& installed via brew) CGAL
  * Played around with a couple of the basic examples with Voro++ and installed gnuplot to view output (see Voro++/examples/basics/README)
  * Installed some (seemingly random) profiling tools for c/c++
    * `brew install qcahegrind --with-graphviz`
    * `brew install --HEAD valgrind`
    * To do: have a gander at [https://kusemanohar.wordpress.com/2012/08/13/c-performance-analysis-profiling-tools/]?
    * To do: need to install XCode Tools & use Instrument (?)

#### Ongoing Notes
  * 1:37pm: Trying to get QHull up and running. the `make` command is failing.
  * Changed a line in the makefile:
    * `bin/testqset_r: src/testqset_r/testqset_r.o src/libqhull_r/qset_r.o src/libqhull_r/mem_r.o src/libqhull/usermem_r.o
  $(CC) -o $@ $^ $(CC_OPTS2) -lm` --> `bin/testqset_r: src/testqset_r/testqset_r.o src/libqhull_r/qset_r.o src/libqhull_r/mem_r.o src/libqhull_r/usermem_r.o
  $(CC) -o $@ $^ $(CC_OPTS2) -lm`
  * `make` now runs but exits with some errors...
  * 2:18pm: made problem size samples with bounding box of 100 with Qhull's rbox. Saved in analysis/data

  * 10.29.15@2:28pm: Realized the voro++ computes 3D voronoi cells, and is not optimized for 2D.
  * 2:35pm: moving on the cgal. installing cmake (`brew install cmake`).
  * 3:35pm: ugh cgal is kind of annoying

  * 10.30.15@3:57pm: looking into triangle, making a script to convert the data generated by rbox to format for triangle
  * 6:06pm: just finished up the script (convert_rbox_to_node.py) that takes the point sets generated by rbox and makes them into triangle-consumable .node files.

  * 10.31.15@12:47pm: finished up scripts to generate a arbitarty number of runs from rbox & cleaned up python script to convert to .node format. going to work on getting hull working.
  * 1:01pm: getting a BUNCH of errors with hull, going to abandon it for now. Getting CGAL again, & thinking about scripts to get the results from all this stuff
  * 3:40pm: scripts to run qhull are working and aggregate results are stashed, now beginning to worry about how all these different libraries implement timing

  * 11.1.15@4:45pm: All the timing data for qhull and triangle have been generated. Here's how:

  ```
  ./analysis/scripts/generate_data.sh 1 6 10 100
  ./analysis/scripts/generate_data.sh 2 21 2 100
  python3 /analysis/scripts/convert_rbox_to_node.py
  python3 /analysis/scripts/run_qvoronoi.py
  python3 /analysis/scripts/run_triangle.py

  ```

    * A note on generate_data.sh: it takes a start order, a max order, a base, and a number of runs. It generates RUNS numbers of files with problemsize base^order for all orders between (& including) the start order & max order.

  * 11.1.15@5:20pm: To do --put all those files in Excel and take a look at 'em. Should also try to get this kind of info for CGAL (?)

  * 11.2.15: got everything plotted out in excel. I suppressed Triangle's file output because it was writing .node and .edge files to my results directory (and taking up time):
   * Note: -N and -E flags are not respected if you use -v, so I changed that in my personal version of Triangle. Added a condition to check switches in triangle.c where write_voronoi is called
   
  * 11.3.15: Thesis mtg
    * to do before 11.10.15
      - [x] graph float, double, long double tpp
      - [x] ch 5 of computer architecture a quantum approach
      - [ ] Answer: what is the implementation of the beachfront & the queue for Triangle
      - [ ] write a loop that reads an array of size 1000, vs 10000, 100000 and adds one or something so you're constantly updating the cache ("thrashing the cache") (this should give an example of the cache "curve" jim has been telling you about)
         - [ ] you have to turn off optimizations(?) since the compiler will try to work around this. so figure out how to do that.

* 11.7.15@10:45am: learn C the hard way
* 12:04pm: Reading ch 5 of Computer Architecture: a Quantitative approach (4th edition).
* 1:44pm: Just found a snipped designed to "Thrash the cache". Here are my [computer's specs] (http://browser.primatelabs.com/geekbench3/684085). I added the same snippet for timing to thrash.c as I did to triangle.c
  * `gcc thrash.c -o thrash` then `./thrash`
  * change  line 110 (array[i][j] = i*j) to (array[j][i] = i*j;)
  * `gcc thrash.c -o thrash` then `./thrash`
  * Notice the time difference

* 11.8.15: Realized that Triangle.c has 3 separate implementations. Running each of those to benchmark.
* 11.9.15@11:41am: finished cleaning up the new data & graphing it





